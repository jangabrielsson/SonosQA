{"name":"SonosProxy","files":[{"name":"SonosLib","isMain":false,"type":"lua","isOpen":false,"content":"--[[\nSonos code lib for the Fibaro Home Center 3\nCopyright (c) 2024 Jan Gabrielsson\nEmail: jan@gabrielsson.com\nGNU GENERAL PUBLIC LICENSE\nVersion 3, 29 June 2007\n\nCopyright (C) 2007 Free Software Foundation, Inc. <https:\/\/fsf.org\/>\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\n--]]\n\n---@diagnostic disable: undefined-global\n--%%name=Sonos\n\n----- Sonos commands\n-- sonos:play(playerName)                  -- Start playing group that player belong to\n-- sonos:pause(playerName)                 -- Pause group that player belong to\n-- sonos:volume(playerName,volume)         -- Set volume to group that player belong to\n-- sonos:relativeVolume(playerName,delta)  -- Set relative volume to group that player belong to\n-- sonos:mute(playerName,state)            -- Mute group that player belong to\n-- sonos:togglePlayPause(playerName)       -- Toggle play\/pause group that player belong to\n-- sonos:skipToNextTrack(playerName)       -- Skip to next track in group that player belong to\n-- sonos:skipToPreviousTrack(playerName)   -- Skip to previous track in group that player belong to\n-- sonos:playFavorite(playerName,favorite,action,modes) -- Play favorite on group that player belong to\n-- sonos:playPlaylist(playerName,playlist,action,modes) -- Play playlist on group that player belong to\n-- sonos:playerVolume(playerName,volume)   -- Set volume of player\n-- sonos:playerRelativeVolume(playerName,delta)         -- Set relative volume of player\n-- sonos:playerMute(playerName,state)      -- Mute player\n-- sonos:clip(playerName,url,volume)       -- Play audio clip on player\n-- sonos:say(playerName,text,volume,lang)  -- Play TTS on player\n-- sonos:playerGroup(playerName)           -- group that player belong to\n-- sonos:playersInGroup(playerName)        -- players in group that player belong to\n-- sonos:createGroup(playerNames,...)      -- group players.\n-- sonos:removeGroup(groupName)            -- remove group. Ex. sonos:removeGroup(sonos:playerGroup(playerName))\n-- sonos:getPlayer(playerName)             -- Get player object. Ex. p = sonos:getPlayer(playerName); p:pause()\n-- sonos:cb(cb)                            -- Set callback function. Ex. sonos:cb(function(h,data) print(event) end):pause(playerName)\nlocal TEST = false\n\nclass 'Sonos'\nSonos.VERSION = \"0.89\"\nfunction Sonos:__init(IP,initcb,debugFlags)\n  self.TIMEOUT = 30\n  local colors = {'lightgreen','lightblue','yellow','orange','purple','pink','cyan','magenta','lime','red'}\n  local coordinators,eventMap,_inited,n = {},{},false,0\n  local SELF,fmt=self,string.format\n  print(fmt(\"SonosLib %s (c)jan@gabrielsson.com\",Sonos.VERSION))\n  self.debug = debugFlags or {}\n\n  local function map(f,l) for k,v in pairs(l) do f(v,k) end end\n  local function LIST(t) return setmetatable(t,{__tostring=function() return table.concat(t,\",\") end}) end\n  local function EVENT(str,ev) return setmetatable(ev,{__tostring=function() return str end}) end\n  local function PLAYER(p) return setmetatable(p,{__tostring=function(p) return fmt(\"[%s:%s]\",p.name,p.id) end}) end\n  local function GROUP(g) return setmetatable(g,{__tostring=function(p) return fmt(\"[%s:%s]\",p.name,p.id) end}) end\n  local function Requests() -- Request queue with timeout handling\n    local self,map,id = {},{},42\n    function self:push(cb,data) local key=tostring(id) id=id+1\n      local ref = setTimeout(function() print(\"TIMEOUT\") cb({namespace=data.namespace,response=data.command,success=false},{reason='Timeout'}) map[key]=nil end,SELF.TIMEOUT*1000) -- Timeout\n      map[key]={cb,ref} return key\n    end\n    function self:pop(key) local cb,ref = table.unpack(map[key] or {}) map[key]=nil if ref then clearTimeout(ref) end return cb end\n    function self:cancelAll() for key in pairs(map) do self:pop(key) end end\n    return self\n  end\n\n  local function createCoordinator(url)\n    if coordinators[url] then return coordinators[url] end\n    local connected,started,buffer,cbs = false,false,{},Requests()\n    local self = {}\n    local sock = net.WebSocketClientTls()\n    local color = colors[n%#colors+1] n=n+1\n    coordinators[url] = self\n\n    local function colorize(col,str) return fmt(\"<font color='%s'>%s<\/font>\",col,str) end\n    local function log(tag,fm,...) if SELF.debug[tag] then print(colorize(color,fmt(fm,...))) end end\n    function self:log(...) log(...) end --export\n\n    local function connect()\n      log(\"socket\",\"Connecting to %s\",url)\n      sock:connect(url, {\n        [\"X-Sonos-Api-Key\"] = \"123e4567-e89b-12d3-a456-426655440000\",\n        [\"Sec-WebSocket-Protocol\"] = \"v1.api.smartspeaker.audio\",\n      })\n    end\n\n    local function dfltCmdLogger(header,obj)\n      log(\"socket\",\"Cmd: %s:%s %s\",header.namespace,header.response,header.success and \"OK\" or colorize(\"red\",\"FAILED\"))\n      if header.success == false then\n        log(\"socket\",\"Reason: %s\",obj.reason or \"\")\n      end\n    end\n\n    function self:send(data,opts,cb,nop)\n      local cont = function()\n        if nop then return end\n        data.cmdId = cbs:push(cb or dfltCmdLogger,data)\n        sock:send(json.encode({data,opts or {}}))\n      end\n      if connected then cont()\n      else\n        if not started then started=true connect() end\n        buffer[#buffer+1] = cont\n      end\n    end\n\n    function self:cmd(data,opts,cb) cb = cb or SELF._cbhook; SELF._cbhook=nil self:send(data,opts,cb,SELF.debug.noCmd) end\n\n    function self:subscribe(resource,id,namespace,cb) self:send({[resource]=id,namespace=namespace,command=\"subscribe\"},nil) end\n\n    function self:getGroups(cb) self:cmd({householdId=SELF.householdId,namespace=\"groups\",command=\"getGroups\"},nil,cb) end\n    function self:getFavorites(cb) self:cmd({householdId=SELF.householdId,namespace=\"favorites\",command=\"getFavorites\"},nil,cb) end\n    function self:getPlaylists(cb) self:cmd({householdId=SELF.householdId,namespace=\"playlists\",command=\"getPlaylists\"},nil,cb) end\n\n    function self:close() if connected then sock:close() log(\"socket\",\"Close\") cbs:cancelAll() connected=false coordinators[url]=nil end end\n\n    sock:addEventListener(\"connected\",function()\n      connected = true log(\"socket\",\"Connected\")\n      for _,cont in ipairs(buffer) do cont() buffer={} end\n    end)\n\n    sock:addEventListener(\"disconnected\",function()\n      log(\"socket\",\"Disconnected\")\n      if connected then -- Socket was involuntarily disconnected, try to reconnect\n        fibaro.warning(__TAG,\"Disconnected - reconnect in 3s\")\n        connected=false\n        setTimeout(function() connect() end,3000)\n      end\n    end)\n\n    sock:addEventListener(\"dataReceived\", function(data)\n      data = json.decode(data)\n      local header,obj = data[1],data[2]\n      if header.cmdId then\n        local rcb = cbs:pop(header.cmdId)\n        if rcb then rcb(header,obj) end\n      elseif eventMap[header.type] then \n        local stat,err = pcall(eventMap[header.type],header,obj,color,self)\n        if not stat then log(\"socket\",\"Error in event handler %s: %s\",header.type,err) end\n        return\n      else log(\"socket\",\"Unknown event: %s\",header.type) end\n    end)\n\n    sock:addEventListener(\"error\", function(err)\n      fibaro.error(__TAG,\"Sonos connection\",err)\n      SELF.post(\"connectionError\",\"\",{reason=\"Connection failed\",url=url},\"red\")\n    end)\n\n    return self\n  end\n\n  local postBuffer = {}\n  local function post(typ,id,args,color)\n    if not _inited then postBuffer[#postBuffer+1]={typ,id,args,color} return end\n    local name = (SELF.groups and SELF.groups[id] or SELF.players and SELF.players[id] or {name='Sonos'}).name\n    color = color or \"white\"\n    local str = fmt('<font color=\"%s\">[%s:\"%s\",%s]<\/font>',color,typ,name,json.encode(args):sub(2,-2))\n    args.type = typ\n    if SELF.eventHandler then SELF.eventHandler(SELF,EVENT(str,args)) else print(str) end\n  end\n  self.post = post --export\n\n  local players,groups = {},{}\n  local function setupPlayers(_players)\n    players = {} self.players = players self.playerNames = LIST({})\n    for _,p in ipairs(_players) do\n      local player = PLAYER({name=p.name, id=p.id, url=p.websocketUrl, coordinator=createCoordinator(p.websocketUrl)})\n      player.softwareVersion = p.softwareVersion\n      player.apiVersion = p.apiVersion\n      player.minApiVersion = p.minApiVersion\n      player.capabilities = p.capabilities\n      players[p.id],players[p.name] = player,player\n      table.insert(self.playerNames,p.name)\n      players[p.id].coordinator:subscribe('playerId',p.id,\"playerVolume\")\n    end\n  end\n\n  local function setupGroups(_groups)\n    local oldGroups = groups groups = {} self.groups = groups self.groupNames = LIST({})\n    for _,g in ipairs(_groups) do\n      local coordinator = players[g.coordinatorId].coordinator\n      local group = oldGroups[g.id]\n      if not group then -- new group\n        group = GROUP({name=g.name, id=g.id, coordinator=coordinator, playerIds=g.playerIds})\n        table.insert(self.groupNames,g.name)\n        group.coordinator:subscribe('groupId',group.id,\"playback\")\n        group.coordinator:subscribe('groupId',group.id,\"groupVolume\")\n        group.coordinator:subscribe('groupId',group.id,\"playbackMetadata\")\n      end\n      groups[g.id],groups[g.name] = group,group\n      map(function(id) players[id].groupId=g.id players[id].group=group end,g.playerIds)\n    end\n    post(\"groupsUpdated\",\"\",{groups=#self.groupNames,players=#self.playerNames})\n  end\n\n  function eventMap.groupVolume(header,obj,color)\n    local group = SELF.groups[header.groupId] if not group then return end\n    group.volume,group.muted=obj.volume,obj.muted post(\"groupVolume\",group.id,{volume=obj.volume,muted=obj.muted},color)\n  end\n\n  function eventMap.playerVolume(header,obj,color)\n    local player = SELF.groups[header.playerId] if not player then return end\n    player.volume,player.muted=obj.volume,obj.muted post(\"playerVolume\",player.id,{volume=obj.volume,muted=obj.muted},color)\n  end\n\n  function eventMap.playbackStatus(header,obj,color)\n    local status = obj.playbackState:match(\"_([%w]*)$\"):lower()\n    local group = SELF.groups[header.groupId] if not group then return end\n    group.playModes = obj.playModes\n    group.playModes._objectType = nil\n    group.status = status post(\"playbackStatus\",group.id,{status=status,modes=group.playModes},color)\n  end\n\n  function eventMap.playerVolume(header,obj,color)\n    local player = self._player[header.playerId]\n    player.volume = obj.volume post(\"playerVolume\",player.id,{volume=obj.volume,muted=obj.muted},color)\n  end\n\n  function eventMap.metadataStatus(header,obj,color)\n    local g = SELF.groups[header.groupId] if not g then return end\n    g.currentTrack = \"\"\n    g.currentArtist = \"\"\n    if obj.currentItem then\n      g.currentTrack =  obj.currentItem.track.name or \"\"\n      g.currentArtist = obj.currentItem.track.artist.name or \"\"\n    end\n    g.currentMetadata = obj\n    g.metadata = obj post(\"metadata\",g.id,{track=g.currentTrack,artist=g.currentArtist},color)\n  end\n\n  function eventMap.versionChanged(header,obj,color,con)\n    if header.namespace == \"favorites\" then\n      con:getFavorites(function(header,obj)\n        SELF.favorites = obj.items\n        post(\"favoritesUpdated\",\"\",{n=#obj.items})\n      end)\n    elseif header.namespace == \"playlists\" then\n      con:getPlaylists(function(header,obj)\n        SELF.playlists = obj.playlists\n        post(\"playlistsUpdated\",\"\",{n=#obj.playlists})\n      end)\n    end\n  end\n\n  -- Could probably use this to tear down group\/coordinator\n  function eventMap.groupCoordinatorChanged(header,obj,color,con) end\n  function eventMap.groups(header,obj) -- Groups changed: rebuild coordinators, groups, players and subscriptions\n    if setupGroups then setupGroups(obj.groups) end\n  end\n\n  self._player=setmetatable({},{__index=function(self,name) local p = SELF.players[name] assert(p,\"Player not found:\"..name) return p end})\n  self._group=setmetatable({},{__index=function(self,name) local g = SELF.groups[name] assert(g,\"Group not found:\"..name) return g end})\n\n  -- Start by getting the householdId, and subscribe to groups, favorites and playlists\n  local connection = createCoordinator(fmt(\"wss:\/\/%s:1443\/websocket\/api\",IP))\n  connection:send({namespace=\"households\",command=\"getHouseholds\"},nil,function(header,data)\n    self.householdId = header.householdId\n    connection:log(\"socket\",\"HouseholdId: %s\",self.householdId)\n    connection:getGroups(function(_,b)\n      setupPlayers(b.players)\n      setupGroups(b.groups)\n      connection:getFavorites(function(_,b)\n        self.favorites = b.items\n        connection:getPlaylists(function(_,b)\n          self.playlists = b.playlists\n          connection:subscribe(\"householdId\",self.householdId,\"favorites\")\n          connection:subscribe(\"householdId\",self.householdId,\"playlists\")\n          connection:subscribe(\"householdId\",self.householdId,\"groups\")\n          if initcb then initcb(self) _inited=true for _,p in ipairs(postBuffer) do post(table.unpack(p)) end end\n        end)\n      end)\n    end)\n  end)\nend\n\nlocal function doCmd(self,rsrc,id,obj,ns,cmd,args)\n  local msg = {namespace=ns,command=cmd,[rsrc]=id}\n  --for k,v in pairs(args or {}) do msg[k]=v end\n  obj.coordinator:cmd(msg,args)\nend\nlocal function doGroupCmd(self,playerName,ns,cmd,args) -- Cmds sent to group coordinator\n  local group = self._player[playerName].group\n  doCmd(self,'groupId',group.id,group,ns,cmd,args)\nend\nlocal function doPlayerCmd(self,playerName,ns,cmd,args) -- Cmds sent to player directly\n  local player = self._player[playerName]\n  doCmd(self,'playerId',player.id,player,ns,cmd,args)\nend\nlocal function find(list,val) for _,i in ipairs(list) do if i.name==val or i.id==val then return i.id end end end\n\nfunction Sonos:play(playerName) doGroupCmd(self,playerName,\"playback\",\"play\") end\nfunction Sonos:pause(playerName) doGroupCmd(self,playerName,\"playback\",\"pause\") end\nfunction Sonos:skipToNextTrack(playerName) doGroupCmd(self,playerName,\"playback\",\"skipToNextTrack\") end\nfunction Sonos:skipToPreviousTrack(playerName) doGroupCmd(self,playerName,\"playback\",\"skipToPreviousTrack\") end\nfunction Sonos:volume(playerName,volume) doGroupCmd(self,playerName,\"groupVolume\",\"setVolume\",{volume=volume}) end\nfunction Sonos:relativeVolume(playerName,delta) doGroupCmd(playerName,\"groupVolume\",\"setVolume\",{volumeDelta=delta}) end\nfunction Sonos:mute(playerName,state) doGroupCmd(self,playerName,\"groupVolume\",\"setMute\",{muted=state~=false}) end\nfunction Sonos:togglePlayPause(playerName) doGroupCmd(self,playerName,\"playback\",\"togglePlayPause\") end\nfunction Sonos:setModes(playerName,m)\n  local modes = { ['rep'..'eat']=m['rep'..'eat'], shuffle=m.shuffle, crossfade=m.crossfade, repeatOne=m.repeatOne }\n  doGroupCmd(self,playerName,\"playback\",\"setPlayModes\",{playModes=modes})\nend\n\nfunction Sonos:playFavorite(playerName,favorite,action,modes)\n  __assert_type(favorite,'string')\n  local favoriteId = find(self.favorites,favorite)\n  if not favoriteId then error(\"Favorite not found: \"..favorite) end\n  doGroupCmd(self,playerName,\"favorites\",\"loadFavorite\",{favoriteId = favoriteId,playOnCompletion = true})\nend\nfunction Sonos:playPlaylist(playerName,playlist,action,modes)\n  __assert_type(playlist,'string')\n  local playlistId = find(self.playlists,playlist)\n  if not playlistId then error(\"Playlist not found: \"..playlist) end\n  doGroupCmd(self,playerName,\"playlists\",\"loadPlaylist\",{playlistId = playlistId, playOnCompletion=true})\nend\nfunction Sonos:playerVolume(playerName,volume) doPlayerCmd(self,playerName,\"playerVolume\",\"setVolume\",{volume=volume}) end\nfunction Sonos:playerMute(playerName,state) doPlayerCmd(self,playerName,\"playerVolume\",\"setMute\",{muted=state~=false}) end\nfunction Sonos:playerRelativeVolume(playerName,volume) doPlayerCmd(self,playerName,\"playerVolume\",\"setRelativeVolume\",{volumeDelta=volume}) end\nfunction Sonos:clip(playerName,url,volume) doPlayerCmd(self,playerName,\"audioClip\",\"loadAudioClip\",{name=\"SW\",appId=\"com.xyz.sw\",streamUrl=url,volume=volume}) end\nfunction Sonos:say(playerName,text,volume,lang)\n  local url=string.format(\"https:\/\/translate.google.com\/translate_tts?ie=UTF-8&client=tw-ob&tl=%s&q=%s\",lang or \"en\",text:gsub(\"%s+\",\"+\"))\n  self:clip(playerName,url,volume)\nend\nfunction Sonos:playerGroup(playerName) return self._group[self._player[playerName].groupId].name end\nfunction Sonos:playersInGroup(groupName) return self._group[groupName].playersIds end\nfunction Sonos:createGroup(...)\n  local playerIds,p = {},nil\n  for _,playerName in ipairs({...}) do p=p or playerName table.insert(playerIds,self._player[playerName].id) end\n  local group = self._player[p].group\n  local msg = {namespace=\"groups\",command=\"createGroup\",householdId=self.householdId}\n  group.coordinator:cmd(msg,{playerIds=playerIds,musicContextGroupId=group.id})\nend\nfunction Sonos:removeGroup(groupName)\n  local group = self._group[groupName]\n  local msg = {namespace=\"groups\",command=\"modifyGroupMembers\",groupId=group.id}\n  group.coordinator:cmd(msg,{playerIdsToRemove=group.playerIds})\nend\nfunction Sonos:cb(cb) self._cbhook = cb return self end\nfunction Sonos:getPlayerObject(playerName) return self._player[playerName] end\nfunction Sonos:getGroupObject(groupName) return self._group[groupName] end\nfunction Sonos:getPlayer(playerName)\n  return setmetatable({},{\n    __index=function(t,cmd) return function(...) self[cmd](self,playerName,...) end end\n  })\nend\n\nlocal _init = QuickApp.__init\nfunction QuickApp:__init(...)\n  if self.preloadSonos then\n    local _onInit = self.onInit\n    function self:onInit()\n      quickApp = self\n      local ip = self.preloadSonos.ip or \"\"\n      local var = ip:match(\"qvar:(.*)\")\n      if var then\n        for _,v in ipairs(self.properties.quickAppVariables) do\n          if v.name == var then ip = v.value break end\n        end\n      end\n      assert(ip and ip~=\"\",\"Sonos IP not set\")\n      Sonos(ip,function(sonos)\n        self.sonos = sonos\n        if _onInit then _onInit(self) end\n      end,self.preloadSonos.debug)\n    end\n  end\n  _init(self,...)\nend\n------------------------- Test code -----------------------\nif TEST then\n  local function delay(args)\n    local t=0\n    for i=1,#args,4 do\n      local d,cond,f,doc=args[i],args[i+1],args[i+2],args[i+3]\n      local function f0() print(\">\"..doc) f() end\n      if cond then t=t+d setTimeout(f0,1000*t) end\n    end\n  end\n\n  function QuickApp:onInit()\n    self:debug(\"onInit\",self.name,self.id)\n\n    local clip = \"https:\/\/github.com\/joepv\/fibaro\/raw\/refs\/heads\/master\/sonos-tts-example-eng.mp3\"\n    function Sonos:eventHandler(event)\n      print(event) -- Just print out events, could be used to ex. update UI\n    end\n    Sonos(\"192.168.1.6\",function(sonos)\n      self:debug(\"Sonos Ready\")\n      print(\"Players:\",sonos.playerNames)\n      print(\"Groups:\",sonos.groupNames)\n      local playerA = sonos.playerNames[1]\n      local playerB = sonos.playerNames[2]\n      local PA = sonos:getPlayerObject(playerA)\n      print(\"PlayerA:\",PA.name,PA.id)\n      local PB = sonos:getPlayerObject(playerB)\n      print(\"PlayerB:\",PB.name,PB.id)\n      print(\"PB:\",PB)\n      local favorite1 = (sonos.favorites[1] or {}).name\n      local playlist1 = (sonos.playlists[1] or {}).name\n      print((\"PlayerA='%s', PlayerB='%s'\"):format(playerA,playerB))\n      print((\"Favorite1='%s', Playlist1='%s'\"):format(favorite1,playlist1))\n      local function callback(headers,data) -- not used\n        print(\"Callback\",headers,data)\n      end\n      delay{\n        -- 1,playerA,function() sonos:say(playerA,\"Hello world\",25) end, \"TTS clip to player\",\n        -- 2,playerB,function() sonos:say(playerB,\"Hello world again\",25) end, \"TTS clip to player\",\n        -- 2,playerA,function() sonos:clip(playerA,clip,25) end, \"Audio clip to player with volume\",\n        -- 2,playerA,function() sonos:play(playerA) end, \"Play group that player belongs to\",\n        -- 2,playerA,function() sonos:pause(playerA) end, \"Pause group that player belongs to\",\n        -- 2,playerB,function() sonos:play(playerB) end, \"Play group that player belongs to\",\n        --2,playerB,function() sonos:cb(callback):pause(playerB) end, \"Pause group that player belongs to\",\n        -- 2,playerB and favorite1,function() sonos:playFavorite(playerB,favorite1) end, \"Play favorite in group that player belongs to\",\n        -- 4,playerB,function() sonos:pause(playerB) end, \"Pause group that player belongs to\",\n        -- 4,playerB and playlist1,function() sonos:playPlaylist(playerB,playlist1) end, \"Play favorite in group that player belongs to\",\n        -- 4,playerB,function() sonos:pause(playerB) end, \"Pause group that player belongs to\",\n        -- 5,playerA and playerB,function() sonos:createGroup(playerB,playerA) end, \"Create group with players\",\n        -- 10,playerA,function() sonos:play(playerA) end, \"Play group that playerA belongs to  (both players)\",\n        -- 4,playerA,function() sonos:removeGroup(sonos:playerGroup(playerA)) end, \"Destroy group playerA belongs to\",\n        -- 4,playerA,function() sonos:play(playerA) end, \"Play group that playerA belongs to (only playerA)\",\n      }\n      -- sonos:volume(playerA,40) -- set volume to group that player belongs to\n      -- sonos:playerVolume(playerA,30) -- set player volume\n      -- local pl = sonos:getPlayer(playerA)\n      -- pl:pause()\n      -- local group = sonos:playerGroup(playerA) -- get group that player belongs to\n      -- local players = sonos:playersInGroup(sonos:playerGroup(playerA)) -- get players in group\n    end,{socket=true, _noCmd=true})\n  end\nend"},{"name":"main","isMain":true,"type":"lua","isOpen":false,"content":"---@diagnostic disable: undefined-global\n_DEVELOP = \"..\/..\/hc3emu\"\nif require and not QuickApp then require(\"hc3emu\") end\n\n \n-- Player type should handle actions: play, pause, stop, next, prev, setVolume, setMute\n--%%name=SonosPlayer\n--%%type=com.fibaro.player\n--%%proxy=SonosProxy\n--%%uid=UPD896846032517895\n--%%save=SonosPlayer.fqa\n\n--%%u={button=\"button_ID_10_1\",text=\"Shuffle\",onReleased=\"doShuffle\"}\n--%%u={label=\"modesLabel\",text=\"Modes:\"}\n--%%u={button=\"btnSay\",text=\"Speak time\",onReleased=\"speakTime\"}\n--%%u={label=\"statusLabel\",text=\"Status:\"}\n--%%u={label=\"artistLabel\",text=\"Artist\"}\n--%%u={label=\"trackLabel\",text=\"Track\"}\n--%%u={label=\"playerLabel\",text=\"Player\"}\n--%%u={select=\"playerSelector\",text=\"Player\",onToggled=\"selectPlayer\",options={{text=\"a\",value=\"a\",type=\"option\"}}}\n--%%u={select=\"favoriteSelector\",text=\"Favorite\",onToggled=\"favoriteSelected\",options={}}\n--%%u={select=\"playlistSelector\",text=\"Playlists\",onToggled=\"playlistSelected\",options={}}\n--%%u={multi=\"groupSelector\",text=\"Group\",onToggled=\"groupSelected\",options={}}\n--%%u={button=\"groupBtn\",text=\"Apply group\",onReleased=\"applyGrouping\"}\n\n--%%file=SonosLib.lua:SonosLib\n\nlocal player,sonos\n-- UI buttons - send command to Sonos\n--fibaro.fibemu.dumpUIfromQA(1918)\nfunction QuickApp:play() sonos:play(player) end\nfunction QuickApp:pause() sonos:pause(player) end\nfunction QuickApp:stop() sonos:pause(player) end\nfunction QuickApp:next() sonos:skipToNextTrack(player) end\nfunction QuickApp:prev() sonos:skipToPreviousTrack(player) end\nfunction QuickApp:setVolume(volume) sonos:volume(player,volume) end\nfunction QuickApp:setMute(mute) sonos:mute(player,mute~=0) end\n\nfunction QuickApp:selectPlayer(ev)\n  player = ev.values[1]\n  self:updatePlayer()\nend\n\nlocal function mode(m) \n   local group = sonos._group[sonos._player[player].groupId]\n   return (group.playModes or {})[m]==true\nend\nfunction QuickApp:doShuffle() sonos:setModes(player,{shuffle=not mode('shuffle')}) end\nfunction QuickApp:doRepeat() sonos:setModes(player,{['repeat']=not mode('repeat')}) end\nfunction QuickApp:doRepeat1() sonos:setModes(player,{repeatOne=not mode('repeatOne')}) end\nfunction QuickApp:doCrossFade() sonos:setModes(player,{crossfade=not mode('crossfade')}) end\nfunction QuickApp:speakTime() sonos:say(player,\"Time is \"..os.date(\"%H:%M\")) end\nfunction QuickApp:favoriteSelected(ev) sonos:playFavorite(player,tostring(ev.values[1])) end\nfunction QuickApp:playlistSelected(ev) sonos:playPlaylist(player,tostring(ev.values[1])) end\n\nlocal groupsSelected = {}\nfunction QuickApp:groupSelected(ev) groupsSelected=ev.values[1] end\nfunction QuickApp:applyGrouping(ev)\n   print(\"SEL:\",json.encode(groupsSelected))\n   -- sonos.createGroup(groupsSelected)\nend\n\nfunction QuickApp:setLabel(name,str)\n   --self:updateView(name,\"text\",string.format(\"<font size='2'><b>%s<\/b><\/font>\",str))\n  self:updateView(name,\"text\",str)\nend\n\nfunction QuickApp:updatePlayer()\n  local group = sonos._group[sonos._player[player].groupId]\n  self:updateView('playerLabel','text',\"Player: \"..(player or \"\"))\n  self:updateView(\"statusLabel\",\"text\",\"Status: \"..(group.status or \"\"))\n  self:updateView(\"artistLabel\",\"text\",\"Artist: \"..(group.currentArtist or \"\"))\n  self:updateView(\"trackLabel\",\"text\",\"Track: \"..(group.currentTrack or \"\"))\n  self:updateProperty(\"state\",group.status or \"\")\n  self:updateProperty(\"volume\",group.volume or 0)\n  self:updateProperty(\"mute\",group.muted or false)\n  local modes = group.playModes or {}\n  local m = {}\n  for k,v in pairs(modes) do if v then m[#m+1]=k end end\n  self:updateView(\"modesLabel\",\"text\",\"Modes: \"..table.concat(m,\",\"))\nend\n\nfunction QuickApp:setOptions(name,list,fun)\n   local options = {}\n   for _,item in ipairs(list) do\n     local text,value = fun(item)\n     options[#options+1] = {text=text,type='option',value=value}\n   end\n   self:updateView(name,\"options\",options)\nend\n\n-- Events from the Sonos player\nlocal EVENT = {}\nfunction EVENT.groupVolume(event) quickApp:updatePlayer() end\nfunction EVENT.playerVolume(event) end\nfunction EVENT.playbackStatus(event) quickApp:updatePlayer() end\nfunction EVENT.metadata(event) quickApp:updatePlayer() end\nfunction EVENT.favoritesUpdated()\n   local function fun(i) return i.name,i.id end\n   quickApp:setOptions(\"favoriteSelector\",sonos.favorites,fun)\nend\nfunction EVENT.playlistsUpdated()\n   local function fun(i) return i.name,i.id end\n   quickApp:setOptions(\"playlistSelector\",sonos.playlists,fun)\nend\n\nfunction QuickApp:onInit()\n    self:debug(\"Player\")\n    quickApp = self\n    Sonos(\"192.168.1.6\",function(_sonos)\n      self:debug(\"Sonos Ready\")\n      sonos = _sonos\n      function sonos:eventHandler(event)\n        if EVENT[event.type] then EVENT[event.type](event)\n        else print(\"Unhandled event:\",json.encode(event)) end\n      end\n      local function fun(i) return i,i end\n      self:setOptions(\"playerSelector\",sonos.playerNames,fun)\n      self:setOptions(\"groupSelector\",sonos.playerNames,fun)\n       player = sonos.playerNames[1]\n       self:updateView(\"playerSelector\",\"selectedItem\", player)\n       self:updateView(\"playerLabel\",\"text\",\"Player:\"..player)\n    end,{socket=true})\nend\n"}],"initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"600"},"title":"quickApp_device_52"},"sections":{"items":[{"style":{"weight":"1.2"},"components":[{"name":"button_ID_10_1","type":"button","visible":true,"text":"Shuffle","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"modesLabel","type":"label","visible":true,"text":"Modes:","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"btnSay","type":"button","visible":true,"text":"Speak time","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"statusLabel","type":"label","visible":true,"text":"Status:","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"artistLabel","type":"label","visible":true,"text":"Artist","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"trackLabel","type":"label","visible":true,"text":"Track","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"playerLabel","type":"label","visible":true,"text":"Player","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"playerSelector","options":[{"text":"a","value":"a","type":"option"}],"style":{"weight":"1.2"},"values":{},"type":"select","visible":true,"selectionType":"single","text":"Player"},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"favoriteSelector","options":{},"style":{"weight":"1.2"},"values":{},"type":"select","visible":true,"selectionType":"single","text":"Favorite"},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"playlistSelector","options":{},"style":{"weight":"1.2"},"values":{},"type":"select","visible":true,"selectionType":"single","text":"Playlists"},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"groupSelector","options":{},"style":{"weight":"1.2"},"values":{},"type":"select","visible":true,"selectionType":"multi","text":"Group"},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"},{"style":{"weight":"1.2"},"components":[{"name":"groupBtn","type":"button","visible":true,"text":"Apply group","style":{"weight":"1.2"}},{"style":{"weight":"0.5"},"type":"space"}],"type":"vertical"}]}},"head":{"title":"quickApp_device_52"}}},"quickAppVariables":[],"uiCallbacks":[{"callback":"doShuffle","eventType":"onReleased","name":"button_ID_10_1"},{"callback":"","eventType":"onLongPressDown","name":"button_ID_10_1"},{"callback":"","eventType":"onLongPressReleased","name":"button_ID_10_1"},{"callback":"speakTime","eventType":"onReleased","name":"btnSay"},{"callback":"","eventType":"onLongPressDown","name":"btnSay"},{"callback":"","eventType":"onLongPressReleased","name":"btnSay"},{"callback":"selectPlayer","eventType":"onToggled","name":"playerSelector"},{"callback":"favoriteSelected","eventType":"onToggled","name":"favoriteSelector"},{"callback":"playlistSelected","eventType":"onToggled","name":"playlistSelector"},{"callback":"groupSelected","eventType":"onToggled","name":"groupSelector"},{"callback":"applyGrouping","eventType":"onReleased","name":"groupBtn"},{"callback":"","eventType":"onLongPressDown","name":"groupBtn"},{"callback":"","eventType":"onLongPressReleased","name":"groupBtn"}],"uiView":[{"style":{"weight":"1.0"},"components":[{"eventBinding":{"onLongPressDown":[{"params":{"args":["onLongPressDown","button_ID_10_1"],"actionName":"UIAction"},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"args":["onLongPressReleased","button_ID_10_1"],"actionName":"UIAction"},"type":"deviceAction"}],"onReleased":[{"params":{"args":["onReleased","button_ID_10_1"],"actionName":"UIAction"},"type":"deviceAction"}]},"style":{"weight":"1.0"},"text":"Shuffle","visible":true,"name":"button_ID_10_1","type":"button"}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"modesLabel","type":"label","visible":true,"text":"Modes:","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"eventBinding":{"onLongPressDown":[{"params":{"args":["onLongPressDown","btnSay"],"actionName":"UIAction"},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"args":["onLongPressReleased","btnSay"],"actionName":"UIAction"},"type":"deviceAction"}],"onReleased":[{"params":{"args":["onReleased","btnSay"],"actionName":"UIAction"},"type":"deviceAction"}]},"style":{"weight":"1.0"},"text":"Speak time","visible":true,"name":"btnSay","type":"button"}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"statusLabel","type":"label","visible":true,"text":"Status:","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"artistLabel","type":"label","visible":true,"text":"Artist","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"trackLabel","type":"label","visible":true,"text":"Track","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"playerLabel","type":"label","visible":true,"text":"Player","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"playerSelector","options":[{"text":"a","value":"a","type":"option"}],"text":"Player","visible":true,"eventBinding":{"onToggled":[{"params":{"args":["onToggled","playerSelector","$event.value"],"actionName":"UIAction"},"type":"deviceAction"}]},"values":{},"type":"select","selectionType":"single","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"favoriteSelector","options":{},"text":"Favorite","visible":true,"eventBinding":{"onToggled":[{"params":{"args":["onToggled","favoriteSelector","$event.value"],"actionName":"UIAction"},"type":"deviceAction"}]},"values":{},"type":"select","selectionType":"single","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"playlistSelector","options":{},"text":"Playlists","visible":true,"eventBinding":{"onToggled":[{"params":{"args":["onToggled","playlistSelector","$event.value"],"actionName":"UIAction"},"type":"deviceAction"}]},"values":{},"type":"select","selectionType":"single","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"name":"groupSelector","options":{},"text":"Group","visible":true,"eventBinding":{"onToggled":[{"params":{"args":["onToggled","groupSelector","$event.value"],"actionName":"UIAction"},"type":"deviceAction"}]},"values":{},"type":"select","selectionType":"multi","style":{"weight":"1.0"}}],"type":"horizontal"},{"style":{"weight":"1.0"},"components":[{"eventBinding":{"onLongPressDown":[{"params":{"args":["onLongPressDown","groupBtn"],"actionName":"UIAction"},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"args":["onLongPressReleased","groupBtn"],"actionName":"UIAction"},"type":"deviceAction"}],"onReleased":[{"params":{"args":["onReleased","groupBtn"],"actionName":"UIAction"},"type":"deviceAction"}]},"style":{"weight":"1.0"},"text":"Apply group","visible":true,"name":"groupBtn","type":"button"}],"type":"horizontal"}],"useEmbededView":true,"buildNumber":1,"apiVersion":"1.3","useUiView":true,"quickAppUuid":"","userDescription":"","supportedDeviceRoles":["Other"],"deviceRole":"Other","typeTemplateInitialized":true,"manufacturer":"","model":""},"type":"com.fibaro.player","apiVersion":"1.3","initialInterfaces":["quickApp"]}